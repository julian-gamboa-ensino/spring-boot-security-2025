# JSON Web Tokens (JWT) in the Car Dealership Microservices Project

## Overview

In the car dealership microservices project, **JSON Web Tokens (JWT)** are used as the primary mechanism for **authentication** and **authorization** across three microservices: `auth-service`, `commerce-service`, and `ui-service`. JWTs ensure secure communication between services, enabling user identification, role-based access control, and support for features like cart management with expiration. This document explains how JWTs are implemented, their structure, usage, and security considerations specific to this project.

---

## Role of JWT in the Project

JWTs are issued by the `auth-service` during user login and are used by the `ui-service` and `commerce-service` to:
- **Authenticate** users by verifying their identity (e.g., CPF as `userId`).
- **Authorize** access to resources based on user roles (e.g., `ROLE_USER`, `ROLE_VENDOR`, `ROLE_ADMIN`).
- Support **stateless** operations, such as associating carts with users and managing vehicle availability.
- Enable **secure communication** between microservices in a distributed system.

### Key Use Cases
1. **User Login**: The `ui-service` sends credentials to the `auth-service`, which returns a JWT containing the user's CPF and roles.
2. **Cart Management**: The `commerce-service` uses the JWT's `userId` to associate carts with users and enforce cart expiration.
3. **Role-Based Access**: The `commerce-service` and `ui-service` restrict endpoints based on roles (e.g., only `ROLE_USER` can manage carts).
4. **Multi-Browser Support**: JWTs allow simultaneous logins from different browsers, maintaining session consistency.

---

## JWT Structure in the Project

A JWT consists of three parts: **Header**, **Payload**, and **Signature**, separated by dots (`.`):  
`Header.Payload.Signature`

Each part is Base64Url-encoded, and the token is signed to ensure integrity.

### 1. **Header**
The header specifies the signing algorithm and token type. In this project:
- **Algorithm**: `HS512` (HMAC with SHA-512), a symmetric algorithm chosen for its strength and simplicity.
- **Type**: `"JWT"`.

**Example**:
```json
{
  "alg": "HS512",
  "typ": "JWT"
}
```

### 2. **Payload**
The payload contains **claims**, which include user information and metadata. The project uses:
- **Registered Claims**:
  - `sub` (subject): The user's CPF (e.g., `12345678901`), used as `userId`.
  - `iat` (issued at): Timestamp when the token was issued.
  - `exp` (expiration): Timestamp when the token expires (24 hours after issuance).
- **Private Claims**:
  - `roles`: List of user roles (e.g., `["ROLE_USER"]`, `["ROLE_VENDOR"]`).

**Example**:
```json
{
  "sub": "12345678901",
  "roles": ["ROLE_USER"],
  "iat": 1697059200,
  "exp": 1697145600
}
```

### 3. **Signature**
The signature is generated by signing the concatenated Base64Url-encoded Header and Payload with a secret key using HS512. The secret is stored securely in the `auth-service` configuration (encrypted via Jasypt).

**Formula**:
```
HMACSHA512(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

---

## Implementation Details

### 1. **auth-service**
The `auth-service` is responsible for generating and validating JWTs. Key components include:

#### **JwtService.java**
- **Token Generation**:
  ```java
  public String generateToken(User user) {
      return Jwts.builder()
          .setSubject(user.getUsername()) // CPF as userId
          .claim("roles", user.getRoles().stream().map(Enum::name).toList())
          .setIssuedAt(new Date())
          .setExpiration(new Date(System.currentTimeMillis() + expiration)) // 24 hours
          .signWith(getSigningKey(), SignatureAlgorithm.HS512)
          .compact();
  }
  ```
  - Uses a 512-bit secret key (configured via `application.yml` and encrypted with Jasypt).
  - Sets `sub` to the user's CPF and includes `roles` as a custom claim.

- **Token Validation**:
  ```java
  public Claims validateToken(String token) {
      try {
          return Jwts.parserBuilder()
              .setSigningKey(getSigningKey())
              .build()
              .parseClaimsJws(token)
              .getBody();
      } catch (JwtException e) {
          throw new AuthenticationException("Invalid or expired token");
      }
  }
  ```
  - Verifies the signature and checks `exp` to ensure the token is valid.

#### **AuthController.java**
- **Login Endpoint** (`/api/auth/login`):
  ```java
  @PostMapping("/login")
  public ResponseEntity<?> login(@RequestParam String username, @RequestParam String password) {
      Map<String, Object> response = new HashMap<>();
      User user = userService.findByUsername(username);
      if (user == null || !userService.validatePassword(password, user)) {
          response.put("success", false);
          response.put("message", "Invalid credentials");
          return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
      }
      String token = jwtService.generateToken(user);
      response.put("success", true);
      response.put("token", token);
      response.put("user", Map.of("id", user.getId(), "username", user.getUsername(), "roles", user.getRoles()));
      return ResponseEntity.ok(response);
  }
  ```
  - Validates credentials, generates a JWT, and returns it to the client.

#### **Configuration**
- **Secret Key**: Stored in `application.yml`, encrypted with Jasypt:
  ```yaml
  jwt:
    secret: ENC(encrypted-secret-key)
    expiration: 86400000 # 24 hours in milliseconds
  ```
- **CryptoConfig.java**: Uses Jasypt to decrypt the secret key:
  ```java
  @Bean
  public Encryptor encryptor() {
      PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
      encryptor.setConfig(simplePBEConfig());
      return encryptor;
  }
  ```

### 2. **commerce-service**
The `commerce-service` validates JWTs to authenticate requests and extract the `userId` and `roles` for cart and vehicle operations.

#### **Security Configuration** (`SecurityConfig.java`):
- Uses Spring Security to enforce JWT validation:
  ```java
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
          .authorizeHttpRequests(auth -> auth
              .requestMatchers("/api/public/**").permitAll()
              .requestMatchers("/api/cart/**").hasAnyRole("USER", "VENDOR")
              .anyRequest().authenticated()
          )
          .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
      return http.build();
  }
  ```
- The `JwtAuthenticationFilter` extracts the JWT from the `Authorization` header (`Bearer <token>`), validates it via `JwtService`, and sets the authentication context.

#### **CartController.java**
- Endpoints like `/api/cart/{cartId}/vehicles/{vehicleId}` use the `userId` from the JWT to associate carts:
  ```java
  @PostMapping("/{cartId}/vehicles/{vehicleId}")
  public ResponseEntity<Void> addVehicleToCart(
      @PathVariable Long cartId,
      @PathVariable Long vehicleId,
      Authentication authentication) {
      String userId = authentication.getName(); // CPF from JWT
      cartService.addToCart(cartId, vehicleId, userId);
      return ResponseEntity.ok().build();
  }
  ```

### 3. **ui-service**
The `ui-service` handles JWTs for user sessions and API calls to the `commerce-service`.

#### **LoginController.java**
- Sends credentials to `auth-service` and stores the JWT in the session:
  ```java
  @PostMapping("/login")
  public String login(@RequestParam String username, @RequestParam String password, HttpSession session, RedirectAttributes redirectAttributes) {
      try {
          Map response = authServiceClient.login(username, password).block();
          if (Boolean.TRUE.equals(response.get("success"))) {
              session.setAttribute("token", response.get("token"));
              session.setAttribute("user", response.get("user"));
              return "redirect:/vehicles";
          }
          redirectAttributes.addFlashAttribute("error", "Invalid credentials");
      } catch (Exception e) {
          redirectAttributes.addFlashAttribute("error", "Login failed");
      }
      return "redirect:/login";
  }
  ```

#### **CartController.java**
- Includes the JWT in API calls to `commerce-service`:
  ```java
  @GetMapping
  public String viewCart(HttpSession session, Model model) {
      String token = (String) session.getAttribute("token");
      Map<String, Object> cart = cartService.getCart(token != null ? token : "").block();
      model.addAttribute("cart", cart);
      return "cart";
  }
  ```

#### **SecurityConfig.java**
- Restricts access to authenticated users:
  ```java
  http
      .authorizeHttpRequests(auth -> auth
          .requestMatchers("/login", "/public/**").permitAll()
          .requestMatchers("/cart/**").hasAnyRole("CLIENTE", "VENDEDOR")
          .anyRequest().authenticated()
      );
  ```

---

## How JWT Supports Cart Expiration

The cart expiration feature (1-minute validity) relies on JWTs for user identification:
1. **User Identification**:
   - The `commerce-service` uses the JWT's `sub` (CPF) to associate carts with users via `Cart.userId`.
   - Example: `CartService.criarCarrinho` sets `cart.setUserId(userId)` based on the JWT.

2. **Role-Based Access**:
   - Only users with `ROLE_USER` can create and manage carts, enforced by `@PreAuthorize("hasRole('USER')")` in `CartController`.

3. **Stateless Validation**:
   - The JWT allows the `commerce-service` to validate requests without querying the `auth-service`, ensuring scalability for cart operations.

4. **Multi-Browser Support**:
   - JWTs stored in HTTP sessions enable simultaneous logins, with each session using a valid token to manage separate carts.

---

## Security Considerations

The project implements several security measures for JWTs, but there are areas for improvement:

1. **Strong Secret Key**:
   - The HS512 algorithm uses a 512-bit secret, encrypted with Jasypt, stored in `application.yml`.
   - **Recommendation**: Rotate secrets periodically and use a secrets management tool (e.g., AWS Secrets Manager).

2. **Expiration**:
   - Tokens expire after 24 hours (`expiration: 86400000` ms), reducing the impact of stolen tokens.
   - **Recommendation**: Implement refresh tokens for long-lived sessions.

3. **Signature Validation**:
   - The `JwtService.validateToken` method checks the signature and `exp` claim.
   - **Recommendation**: Explicitly validate `alg` to prevent algorithm confusion attacks.

4. **Sensitive Data**:
   - The payload includes the CPF (`sub`) and `roles`, which are not encrypted but are protected by HTTPS.
   - **Recommendation**: Avoid adding sensitive data to the payload unless encrypted.

5. **HTTPS**:
   - All communication between services uses HTTPS, preventing token interception.
   - **Recommendation**: Enforce strict TLS configurations.

6. **Token Storage**:
   - The `ui-service` stores JWTs in HTTP sessions, which are secure but vulnerable to session hijacking.
   - **Recommendation**: Use HTTP-only, secure cookies with CSRF protection.

7. **Token Revocation**:
   - The project does not implement token revocation, relying on short expiration times.
   - **Recommendation**: Maintain a token blacklist for logout or compromised tokens.

8. **Role-Based Access**:
   - Roles (`ROLE_USER`, `ROLE_VENDOR`, `ROLE_ADMIN`) are validated in both `commerce-service` and `ui-service`.
   - **Recommendation**: Centralize role validation logic in a shared library.

---

## Advantages in the Project

- **Stateless Authentication**: No need for session storage, improving scalability for cart operations.
- **Role-Based Access**: Simplifies access control for cart (`ROLE_USER`) and sales (`ROLE_VENDOR`) features.
- **Inter-Service Security**: JWTs enable secure communication between microservices.
- **Multi-Browser Support**: Facilitates simultaneous logins, critical for testing cart expiration.

---

## Disadvantages in the Project

- **No Revocation**: Stolen tokens remain valid until expiration.
- **Session Dependency**: The `ui-service` relies on HTTP sessions, which may not scale as well as token-based clients.
- **Fixed Expiration**: 24-hour token validity may be too long for sensitive operations.

---

## Example Workflow

1. **User Login**:
   - A user submits CPF (`12345678901`) and password via `ui-service` (`/login`).
   - The `ui-service` calls `auth-service` (`/api/auth/login`), which returns:
     ```json
     {
       "success": true,
       "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwMSIsInJvbGVzIjpbIlJPTEVfVVNFUiJdLCJpYXQiOjE2OTcwNTkyMDAsImV4cCI6MTY5NzE0NTYwMH0.signature",
       "user": {
         "id": 1,
         "username": "12345678901",
         "roles": ["ROLE_USER"]
       }
     }
     ```
   - The `ui-service` stores the token in the session.

2. **Add Vehicle to Cart**:
   - The user adds a vehicle via `ui-service` (`/cart/add`), which calls `commerce-service` (`/api/cart/{cartId}/vehicles/{vehicleId}`) with the `Authorization: Bearer <token>` header.
   - The `commerce-service` validates the token, extracts `userId` (`12345678901`), and associates the cart.

3. **Cart Expiration**:
   - The `commerce-service` sets a 1-minute expiration for the cart, independent of the JWT's 24-hour validity.
   - If the user attempts checkout after expiration, the `commerce-service` rejects it, and the `ui-service` displays: `"Veículo não está mais disponível no carrinho"`.

---

## Debugging JWTs

- **Tools**:
  - Use [jwt.io](https://jwt.io/) to decode and inspect tokens.
  - Check logs in `auth-service` for token generation/validation errors.
- **Common Issues**:
  - **Invalid Signature**: Ensure the secret key matches across services.
  - **Expired Token**: Verify the `exp` claim and system clock synchronization.
  - **Missing Roles**: Confirm the `roles` claim includes expected values (e.g., `ROLE_USER`).

---

## Recommendations for Improvement

1. **Implement Refresh Tokens**:
   - Add a `/api/auth/refresh` endpoint in `auth-service` to issue new tokens without re-authentication.
2. **Shorten Token Expiration**:
   - Reduce `expiration` to 1 hour for sensitive operations, using refresh tokens for session continuity.
3. **Add Token Blacklist**:
   - Store revoked tokens in a database or Redis cache for logout functionality.
4. **Centralize JWT Validation**:
   - Create a shared library for JWT parsing and validation to ensure consistency across services.
5. **Enhance Error Handling**:
   - Return specific error codes for JWT issues (e.g., `401` for expired tokens, `403` for missing roles).

---

## Conclusion

JWTs are integral to the car dealership microservices project, enabling secure, stateless authentication and authorization. The `auth-service` generates tokens with user CPF and roles, which the `commerce-service` and `ui-service` use to manage carts and restrict access. While the implementation is robust, adding refresh tokens, revocation, and shorter expiration times would enhance security. By following the outlined practices, the project ensures a scalable and secure system for managing vehicle sales and cart expiration.

For further details:
- Review `JwtService.java` in `auth-service` for token logic.
- Check `SecurityConfig.java` in `commerce-service` and `ui-service` for access control.
- Test JWT workflows using Postman or [jwt.io](https://jwt.io/).