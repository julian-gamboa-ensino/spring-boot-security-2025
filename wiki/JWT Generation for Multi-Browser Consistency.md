# JWT Generation for Multi-Browser Consistency in the Car Dealership Microservices Project

## Introduction

In the car dealership microservices project, **JSON Web Tokens (JWT)** are generated by the `auth-service` based on user credentials (CPF and password), producing **identical tokens** for simultaneous logins from multiple browsers using the same credentials. These tokens have the same `sub` (subject, the user’s CPF), `roles` (user permissions), and `exp` (expiration time), ensuring consistent user identification and authorization across browsers. This document explains the role of the `sub` claim, how JWTs are generated, why they are identical for the same credentials, and how this supports multi-browser consistency, particularly for cart management with 1-minute expiration.

---

## What is the `sub` Claim?

The **`sub`** (subject) claim is a **registered claim** in the JWT standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that identifies the principal entity associated with the token, typically the user.

- **In the Project**:
  - The `sub` contains the **CPF** of the user (e.g., `12345678901`), serving as the unique identifier (`userId`).
  - It is used by the `commerce-service` to associate actions (e.g., cart creation, vehicle reservation) with the correct user.
  - Example JWT payload:
    ```json
    {
      "sub": "12345678901",
      "roles": ["ROLE_USER"],
      "iat": 1697059200,
      "exp": 1697145600
    }
    ```

- **Purpose**:
  - The `sub` ensures that all requests from a user are linked to their identity (CPF), enabling consistent data management across browsers.
  - It supports the stateless nature of JWTs, as the `commerce-service` can extract the `userId` directly from the token without querying the `auth-service`.

- **Code Usage**:
  - The `commerce-service` extracts the `sub` as `userId`:
    ```java
    String userId = authentication.getName(); // CPF from JWT's sub
    cartService.addToCart(cartId, vehicleId, userId);
    ```

---

## Other Relevant Claims

- **`roles`**:
  - A **private claim** defined by the project, listing the user’s roles (e.g., `["ROLE_USER"]`, `["ROLE_VENDOR"]`).
  - Used for **authorization**, determining access to endpoints (e.g., only `ROLE_USER` can manage carts).
  - Set in the JWT:
    ```java
    .claim("roles", user.getRoles().stream().map(Enum::name).toList())
    ```

- **`exp` (expiration)**:
  - A **registered claim** indicating when the token expires (Unix timestamp).
  - In the project, set to **24 hours** after issuance (`expiration = 86400000` ms).
  - Ensures tokens are not valid indefinitely, enhancing security.
  - Set in the JWT:
    ```java
    .setExpiration(new Date(System.currentTimeMillis() + expiration))
    ```

---

## How JWTs Are Generated with Identical Claims

The `auth-service` generates JWTs based on user credentials, producing identical tokens for logins with the same CPF and password. Here’s how:

### 1. **Login Process**
- The user submits their CPF and password via the `ui-service` (`/login`), which calls the `auth-service` (`/api/auth/login`):
  ```java
  @PostMapping("/login")
  public ResponseEntity<?> login(@RequestParam String username, @RequestParam String password) {
      Map<String, Object> response = new HashMap<>();
      User user = userService.findByUsername(username);
      if (user == null || !userService.validatePassword(password, user)) {
          response.put("success", false);
          response.put("message", "Invalid credentials");
          return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
      }
      String token = jwtService.generateToken(user);
      response.put("success", true);
      response.put("token", token);
      response.put("user", Map.of("id", user.getId(), "username", user.getUsername(), "roles", user.getRoles()));
      return ResponseEntity.ok(response);
  }
  ```

- **Credential Validation**:
  - The `userService.findByUsername(username)` retrieves the user by CPF (e.g., `12345678901`).
  - The `userService.validatePassword` checks the password (using BCrypt in the project).
  - If valid, the user’s data (CPF, roles) is used to generate the JWT.

### 2. **JWT Generation**
- The `JwtService.generateToken` creates the JWT:
  ```java
  public String generateToken(User user) {
      return Jwts.builder()
          .setSubject(user.getUsername()) // CPF as sub
          .claim("roles", user.getRoles().stream().map(Enum::name).toList())
          .setIssuedAt(new Date())
          .setExpiration(new Date(System.currentTimeMillis() + expiration)) // 24 hours
          .signWith(getSigningKey(), SignatureAlgorithm.HS512)
          .compact();
  }
  ```
- **Claims Set**:
  - `sub`: Set to `user.getUsername()`, the user’s CPF (e.g., `12345678901`).
  - `roles`: Set to the user’s roles (e.g., `["ROLE_USER"]`).
  - `iat`: Current timestamp (e.g., `1697059200`).
  - `exp`: Current timestamp + 24 hours (e.g., `1697145600`).
  - Signature: Generated using the HS512 algorithm and a secret key (stored in `application.yml`, encrypted with Jasypt).

- **Why Identical?**:
  - For the same CPF and password, `userService.findByUsername` returns the same `User` object with the same CPF and roles.
  - The `iat` and `exp` are based on the system clock, so logins em rápida sucessão (ex.: segundos de diferença) têm timestamps praticamente idênticos.
  - The same secret key and HS512 algorithm ensure the same signature for the same payload.
  - Thus, JWTs generated for the same credentials are identical in content (`sub`, `roles`, `exp`).

### 3. **Multi-Browser Implications**
- **Login in Multiple Browsers**:
  - When the user logs in on Chrome and Firefox with CPF `12345678901` and the same password, both browsers receive the same JWT (e.g., `eyJhbGciOiJIUzUxMi...` with `sub: "12345678901"`, `roles: ["ROLE_USER"]`, `exp: 1697145600`).
  - The `ui-service` stores each JWT in the respective browser’s `HttpSession`:
    ```java
    session.setAttribute("token", response.get("token"));
    ```

- **Request Processing**:
  - Each browser sends the same JWT to the `commerce-service` via `Authorization: Bearer <token>`:
    ```java
    String token = (String) session.getAttribute("token");
    cartService.getCart(token).block();
    ```
  - The `commerce-service` validates the JWT and extracts the `sub` as `userId`:
    ```java
    String userId = authentication.getName(); // CPF from sub
    ```
  - Since the `sub` is the same (`12345678901`), all browser requests affect the same user-specific data (e.g., the same cart).

- **Consistency**:
  - The identical JWTs ensure that the `commerce-service` treats all requests as coming from the same user, linking actions to the same `userId`.
  - The database (via `Cart.userId`) maintains a single cart state, ensuring all browsers see consistent data (e.g., same vehicles, same expiration time).

---

## Example Workflow

Consider a user with CPF `12345678901`:
1. **Login on Chrome**:
   - The user logs in via `ui-service` (`/login`), and the `auth-service` generates a JWT:
     ```json
     {
       "sub": "12345678901",
       "roles": ["ROLE_USER"],
       "iat": 1697059200,
       "exp": 1697145600
     }
     ```
   - The JWT is stored in Chrome’s `HttpSession`.

2. **Login on Firefox**:
   - The user logs in with the same CPF and password. The `auth-service` generates an identical JWT (same `sub`, `roles`, `exp`, as the credentials and generation logic are the same).
   - The JWT is stored in Firefox’s `HttpSession`.

3. **Cart Creation**:
   - In Chrome, the user adds vehicle ID `1` to a cart. The `ui-service` sends the JWT to `commerce-service`, which validates it and creates a cart with `userId = 12345678901`, `expirationTime = now + 1 minute`.
   - In Firefox, the user views the cart. The `commerce-service` validates Firefox’s JWT (same `sub`) and returns the cart with vehicle ID `1`.

4. **Concurrent Action**:
   - In Firefox, the user adds vehicle ID `2`. The `commerce-service` validates the JWT, updates the same cart (`userId = 12345678901`), and resets `expirationTime`.
   - Chrome refreshes the cart view, sending its JWT. The `commerce-service` retrieves the cart, showing vehicles `1` and `2`.

5. **Expiration**:
   - After 1 minute, the `cleanExpiredCarts` task marks the cart as `EXPIRED`.
   - Both browsers attempt checkout, and the `commerce-service` returns `"Veículo não está mais disponível no carrinho"`.

**Consistency**:
- The identical JWTs (`sub: "12345678901"`) ensure that both browsers interact with the same cart, tied to the same `userId` in the database.

---

## Advantages of Identical JWTs

1. **Consistent User Identification**:
   - The same `sub` (CPF) across browsers ensures all actions are linked to the same user, maintaining a single cart state.

2. **Stateless Authentication**:
   - The `commerce-service` validates JWTs without querying the `auth-service`, as the `sub` and `roles` are embedded, improving efficiency.

3. **Multi-Browser Support**:
   - Identical JWTs allow multiple browsers to authenticate as the same user, supporting simultaneous logins without conflicts.

4. **Simplified Consistency**:
   - The database uses `userId` (from `sub`) as the single source of truth, ensuring all browsers see the same cart state (e.g., vehicles, expiration).

---

## Limitations

1. **HTTP Session Dependency**:
   - The `ui-service` stores JWTs in `HttpSession`, introducing server-side state, which contrasts with the stateless nature of JWTs.
   - **Recommendation**: Use HTTP-only, secure cookies:
     ```java
     Cookie cookie = new Cookie("jwt", token);
     cookie.setHttpOnly(true);
     cookie.setSecure(true);
     response.addCookie(cookie);
     ```

2. **No Token Revocation**:
   - Identical JWTs mean that a stolen token can be used across browsers until it expires (24 hours).
   - **Recommendation**: Implement a token blacklist:
     ```java
     public void revokeToken(String token) {
         tokenBlacklistRepository.save(new BlacklistedToken(token, LocalDateTime.now().plusHours(24)));
     }
     ```

3. **Single Cart Restriction**:
   - The same `sub` enforces one cart per user, preventing browsers from managing separate carts.
   - **Recommendation**: Add a `sessionId` claim to the JWT:
     ```json
     {
       "sub": "12345678901",
       "sessionId": "browser-uuid",
       "roles": ["ROLE_USER"]
     }
     ```

4. **Timestamp Precision**:
   - While `iat` and `exp` are nearly identical for simultaneous logins, slight timestamp differences (milliseconds) could occur. This is negligible in practice but could be standardized.
   - **Recommendation**: Use a fixed `exp` offset from login time to ensure exact matches.

---

## Recommendations for Improvement

1. **Client-Side JWT Storage**:
   - Store JWTs in HTTP-only cookies to eliminate `HttpSession` dependency:
     ```java
     @PostMapping("/login")
     public ResponseEntity<?> login(@RequestParam String username, @RequestParam String password, HttpServletResponse response) {
         Map authResponse = authServiceClient.login(username, password).block();
         if (Boolean.TRUE.equals(authResponse.get("success"))) {
             Cookie cookie = new Cookie("jwt", (String) authResponse.get("token"));
             cookie.setHttpOnly(true);
             cookie.setSecure(true);
             cookie.setPath("/");
             response.addCookie(cookie);
             return ResponseEntity.ok().build();
         }
         return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
     }
     ```
   - Add CSRF protection for security.

2. **Refresh Tokens**:
   - Implement refresh tokens to allow shorter JWT expiration (e.g., 1 hour):
     ```java
     @PostMapping("/refresh")
     public ResponseEntity<?> refreshToken(@RequestParam String refreshToken) {
         // Validate refresh token and issue new JWT
     }
     ```

3. **Multiple Carts**:
   - Support multiple carts by adding a `sessionId` to the JWT or database:
     ```java
     @Transactional
     public Cart criarCarrinho(String userId, String sessionId) {
         Cart cart = new Cart();
         cart.setUserId(userId);
         cart.setSessionId(sessionId);
         return cartRepository.save(cart);
     }
     ```

4. **Optimistic Locking**:
   - Use the `version` field in `Vehicle` and `Cart` for concurrency control:
     ```java
     @Version
     private Long version;
     ```

---

## Conclusion

The generation of **identical JWTs** for simultaneous logins with the same credentials (CPF/senha) is a key feature of the car dealership project’s multi-browser support. The `sub` claim (CPF) uniquely identifies the user, ensuring that all browser requests are linked to the same `userId`. The `roles` claim enforces authorization, and the `exp` claim limits token validity to 24 hours. By producing identical JWTs, the `auth-service` allows multiple browsers to authenticate as the same user, while the `commerce-service` uses the `sub` to maintain a consistent cart state in the database. Improvements like client-side JWT storage, refresh tokens, and multiple carts can enhance flexibility and security, building on the stateless foundation of JWTs.

For further exploration:
- Test simultaneous logins with Postman to verify identical JWTs.
- Review `JwtService.java` for token generation logic.
- Implement cookie-based JWT storage to reduce server-side state.